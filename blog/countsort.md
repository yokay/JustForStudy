[TOC]

计数排序(count sort)
---
对于算法导论上的计数排序的说法，我一直有点头晕的感觉，讲了大半天，虽然结果出来了，但是为什么这个方法可以却一直想不出原因。为了比较通俗的讲清楚，我先把算法导论官方的过程说明一下。  
众所周知，计数排序需要3个数组：源数组、排序数组和临时数组。源数组是要排序的数组，排序数组是最终排好的数组，临时数组放的是计数值，不需要对排序数组进行重组，只是填充排好的数。  
以算法导论例子讲解：  
```C
	源数组		A: 2 5 3 0 2 3 0 3  
	临时数组	B: 0 0 0 0 0 0 0 0  
	排序数组	C: 0 0 0 0 0 0 0 0  
```

（1）首先要找出A中最大的元素作为k值    
这里想当然的是`5`，毋庸置疑。但是在我们不知道的情况下，或者说如何让计算机自己找出最大值(我们不可能每次排序都要手动给最大值)，必须通过一定的手段找出最大值，有时候为了减少空间，还需要找到最小值。  
假如已经找到最大、最小值——`5`和`0`，这样我们的临时数组必须要放的了`0~5`的所有数据，也就是说B数组中放的是对应`0~5`的所有数的个数，这样就能对每个数字进行计数。将A中数据与`0~5`对应，相应的叠加，通俗点说就是放**个数**。  
```C
	源数组		A: 2 5 3 0 2 3 0 3  
				   0 1 2 3 4 5	  
	临时数组	B: 2 0 2 3 0 1     
```
其实这里你也看出来数据已经排好了，为什么这么说呢？待会再讲。  

（2）再对B做"叠加运算"    
这里说的"叠加"运算，其实是这样的，将B中数与其前面的数叠加。  
```C
	源数组		A: 2 5 3 0 2 3 0 3  
				   0 1 2 3 4 5	  
	临时数组	B: 2 2 4 7 7 8  
```
这里得出的叠加值可以看成`<=`对应的`0~5`的数的个数。  

（3）最后逆序遍历A，将A中的值作为B的下标，找到C中要放此A的数的位置，然后将对应B出的计数值减一    
这样说可能有点糊。以上面的来说，从A的最后一个数`3`来说，A[8] = 3，将`3`作为B的下标得到B[3] = 7，然后C[7] = 3。B[3] -= 1，即B[3] = 6。  
```C
	源数组		A: 2 5 3 0 2 3 0 3    
				   0 1 2 3 4 5	    
	临时数组	B: 2 2 4 7 7 8      
	排序数组	C: 0 0 2 2 3 3 3 5	  
				   1 2 3 4 5 6 7 8  
```
由上可得到排序数组C。上面的说法很学术，不知其所以然。现在通俗的说下为什么这样做可以。  
我们平常排序都是`1 2 3 4 5 。。。`这样的顺序(或者逆序)，不管有没有相同的数据都是这样子排，在（1）过程中我们已经看到了排序的端倪，即B的计数值表示是对应的数的个数，如果我们排除相同的值或者说只记一次，那么就等同于把0放在0位，1放在1位。。。这就是在排序了。想象一下A是一组扑克牌，现在将相同的扑克落在一起，然后打包排序。从（1）可得排序的数必然是：  
```C
				0 2 3 5    
	行表示：	[0 0][][2 2][3 3 3][][5]    
	列表示：	0 2 3 5    
				0 2 3   
				    3  
```

对于没有的自然不管，将相同的放在一起。对已知的数据进行自然的排序，当然是这样，这是毫无疑问的。然后再排序就可以不管其先前的顺序了，于是进行改进后可以这样做，当对C进行填充时，从小到大按照（1）中B的数据个数进行填充即可。但是这样子就违反了排序的规则，即使是相同的数它们也是有尊严的不是么，怎么能让你随便放哪里呢，原来怎么个顺序就得怎么来。就算是扑克牌也有"黑红梅方"的潜规则顺序啊，何况它们一开始就已经排好了，天命不可违啊~  

所以我们要统计在你之前(包括你自身)有多少数据是小于等于你的，这样就可以知道你的位置了。从（2）中看出，0之前的数据个数是2，1之前的数(虽然没有1，但是0<1)是0，由于没有1为空，处于0的位置(1既然没有，何必要强加在0后面呢)。。。由此得到下面的数：  
```C
	源数组		A: 2 5 3 0 2 3 0 3  
			<=	   0 1 2 3 4 5	 
		           ---个数----
			1	   0 0 0 0 0 0
			2	   0 0 0 0 0 0
			3	   	   2 2 2 2
			4	   	   2 2 2 2
			5	   	     3 3 3
			6	   	     3 3 3
			7	   	     3 3 3
			8	   	         5
	临时数组	B: 2 2 4 7 7 8  
```
这样我们大致可以看出5要放到第8位，3(3)放大第7位，3(2)放到第6位，3(1)放到第5位，2(2)放到第4位，2(1)放到第3位，0(2)放到第2位，0(1)放到第1位。这样数据就排好了，而且还没招惹各位大仙。  
那么B现在放的计数值表示的就是`<=`此处值的个数，如果3(3)已经在C里面，为了不抢3(3)的位置的，放好了就把`<=`3的计数减个1，表示除了3(3)之外还有几个`<=`3的个数。每次从老大开始排，A靠后的先放好，其实从前往后都是一样的，只是调换了原先的位置。  

我们在看个有趣的例子：  
`2 5 6 7 9 1 8 3 4 `  
这个例子中没有重复的数，每个数计数值都是`1`。排序后必然为  
```C
下标：1 2 3 4 5 6 7 8 9  
	  1 2 3 4 5 6 7 8 9    
```
那么对应下标的数据就是该下标(如果数组从1开始)。  
我们可以这么说以前是显示：  
`A[2] A[5] A[6] A[7] A[9] A[1] A[8] A[3] A[4] `     
现在我们要顺序显示，怎么做？直接输出：  
`A[1] A[2] A[3] A[4] A[5] A[6] A[7] A[8] A[9] `   
因为我们对应位置放着对应的数。  
比如说8放哪里？8放A的第8位。  
排序后的数组永远是A[1:9]，它不变，我们只需要将对应的数放进去即可。对于没有的我们大可将后面的数占用它，只是要将下标前移。  

我们重新拿算法导论的例子来说明这个，就说最后那个3，它是A[8] = 3，在B'中B'[3] = 3。那么B'[A[8]]不就是A[8]的值么，因为B'数组是个`元素值就是下标值得数组`。B[B'[3]]就是该数字的个数。(B'表示头上的`0~5`)    
这样对应的B中的数据个数就是该B'数所在的位置，也就是排序后所要占的位置。  
说了大半天绕嘴的废话，其实就是为了说明临时数组的作用，不知道有没有讲清楚。  

Hi！大家好，我是yokay。不知道现在学算法是否已垂暮，总之我还是想把学习的过程写下来。  
首先是最简单的插入法——Insertion sort，这是《算法导论》的开山之讲，显然我没搞清楚，(-__-)b  

插入排序，就是插入+排序，合称“插入排序”。文中以扑克为例，我以军训时排队为例，排队时为了保证整齐，我们要找准我们的位置，然后插入进去。先以自己为对象，比较别人的身高，挨个比较，然后找到合适的位置，这就是插入排序的精髓，你懂的。  

以树上例子来讲： 

0  |1  |2  |3  |4  |5  |
---|---|---|---|---|---|
5  |2  |4  |6  |1  |3  |

对上例中6个数据进行插入式排序，根据上面讲的，对每一个数字与前后的数字进行比较，然后排序，大数靠后，小数前移。    
(1):    

0  |1	  |--->|				0  |1	
---|---   |--->|				---|---	
5  |2	  |--->|				2  |5	 

(2):       

0  |1  |2	  |--->|				0  |1  |2  |
---|---|---	  |--->|				---|---|---|
2  |5  |4	  |--->|				2  |4  |5  |

(3):    

0  |1  |2  |3	  
---|---|---|--- 
2  |4  |5  |6  

(4):  

0  |1  |2  |3  |4  		|--->|		0  |1  |2  |3  |4  		|--->|	0  |1  |2  |3  |4  		|--->|	0  |1  |2  |3  |4  		|--->|	0  |1  |2  |3  |4  
---|---|---|---|---		|--->|		---|---|---|---|---		|--->|	---|---|---|---|---		|--->|	---|---|---|---|---		|--->|	---|---|---|---|---
2  |4  |5  |6  |1     	|--->|		2  |4  |5  |1  |6  	 	|--->|	2  |4  |1  |5  |6  		|--->|	2  |1  |4  |5  |6 		|--->|	1  |2  |4  |5  |6  


(5):

0  |1  |2  |3  |4  |5	|--->|	0  |1  |2  |3  |4  |5		|--->|	0  |1  |2  |3  |4  |5	|--->|	0  |1  |2  |3  |4  |5
---|---|---|---|---|	|--->|	---|---|---|---|---|		|--->|	---|---|---|---|---|		|--->|	---|---|---|---|---|	
1  |2  |4  |5  |6  |3	|--->|	1  |2  |4  |5  |3  |6		|--->|	1  |2  |4  |3  |5  |6	|--->|	1  |2  |3  |4  |5  |6

通过上面的推导过程即可以看出插入排序的基础思想。  
每次执行时，都要将要处理的数进行比较，并移动到合适的位置。如果为升序，并且当前数满足升序条件则不移动。  

程序如下：  
```C
void insertion_sort(int *A, int A_length)
{
	int key;	//key值为当前值
	int i, j;	//用i,j去索引数据
	int tmp;	//用于暂存数据

	for (j = 1; j < A_length; j++)
	{
		key = A[j];	//从第二个数开始，j为第二个数
		i = j - 1;	//i为j前面的数
		while ((i >= 0)&& (A[i] > key))
		{
			tmp = A[i];
			A[i] = key;
			A[i+1] = tmp;
			i -= 1;
		}
	}
}
```

测试用例:
```C
#include <stdio.h>

void insert_sort(int *num, int length)
{
    int i, j, tmp;
    for (j = 1; j < length; j++) {
        for (i = 0; i < j; i++) {
            if (num[j] < num[i]) {
                tmp = num[j];
                num[j] = num[i];
                num[i] = tmp;
            }
         printf("%d", num[i]);
        }
     printf("%d\n", num[j]);
    }
}

void insertion_sort(int *A, int A_length)
{
	int key;	//key值为当前值
	int i, j;	//用i,j去索引数据
	int tmp;	//用于暂存数据

	for (j = 1; j < A_length; j++)
	{
		key = A[j];	//从第二个数开始，j为第二个数
		i = j - 1;	//i为j前面的数
		while ((i >= 0)&& (A[i] > key))
		{
			tmp = A[i];
			A[i] = key;
			A[i+1] = tmp;
			i -= 1;
		}
	}
}

void main()
{
    int i = 0;
    int number[] = {5, 2, 4, 6, 1, 3};
    insertion_sort(number, 6);
    for (i = 0; i < 6; i++)
        printf("%d-", number[i]);
}

gcc -g insert_sort.c -o insert_sort 结果为1-2-3-4-5-6-
```

从程序中可以看到有个嵌套的循环，可见时间复杂度较高。  
插入排序法适用于少量数据，其是一个稳定的排序算法，时间复杂度为O(n^2)。

参考资料：  
维基百科：[插入排序][1]

[1]:(http://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F)